<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storage V2 DApp - Blockchain Smart Contract</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }
        
        .section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .info-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        
        .info-item strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
        }
        
        .info-item span {
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }
        
        input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .status {
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            font-weight: 500;
        }
        
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .event-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .event-item h5 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .network-info {
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            color: #2d3436;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .library-status {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
        }
        
        .wallet-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .wallet-btn {
            background: white;
            color: #333;
            border: 2px solid #667eea;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .wallet-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-1px);
        }
        
        .wallet-btn.connected {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        
        .footer {
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            color: #6c757d;
            border-top: 1px solid #e9ecef;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
            
            .section {
                padding: 20px;
            }
            
            .wallet-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Storage V2 DApp</h1>
            <p>Decentralized Storage Smart Contract on GIWA Sepolia Testnet</p>
        </div>
        
        <div class="content">
            <div class="library-status" id="libraryStatus">
                üìö Initializing DApp...
            </div>
            
            <div class="network-info">
                <strong>‚ö†Ô∏è Make sure you're connected to GIWA Sepolia Testnet!</strong>
            </div>
            
            <div class="section">
                <h3>üìä Contract Information</h3>
                <div class="info-grid">
                    <div class="info-item">
                        <strong>Contract Address:</strong>
                        <span id="contractAddr">0x61123b7a22d2f1b8c2c4becc8333e8e4209cce28</span>
                    </div>
                    <div class="info-item">
                        <strong>Current Stored Value:</strong>
                        <span id="currentValue">Not connected</span>
                    </div>
                    <div class="info-item">
                        <strong>Contract Owner:</strong>
                        <span id="contractOwner">Not connected</span>
                    </div>
                    <div class="info-item">
                        <strong>Your Address:</strong>
                        <span id="userAddress">Not connected</span>
                    </div>
                    <div class="info-item">
                        <strong>Are you the owner?</strong>
                        <span id="isOwner">Unknown</span>
                    </div>
                    <div class="info-item">
                        <strong>Network:</strong>
                        <span id="networkName">Not connected</span>
                    </div>
                    <div class="info-item">
                        <strong>Connected Wallet:</strong>
                        <span id="connectedWallet">None</span>
                    </div>
                </div>
                
                <h4 style="margin-bottom: 10px;">Connect Your Wallet:</h4>
                <div class="wallet-buttons">
                    <button class="wallet-btn" onclick="connectWallet('metamask')" id="metamaskBtn">
                        ü¶ä MetaMask
                    </button>
                    <button class="wallet-btn" onclick="connectWallet('rabby')" id="rabbyBtn">
                        üê∞ Rabby
                    </button>
                    <button class="wallet-btn" onclick="connectWallet('coinbase')" id="coinbaseBtn">
                        üîµ Coinbase Wallet
                    </button>
                    <button class="wallet-btn" onclick="connectWallet('walletconnect')" id="walletconnectBtn">
                        üì± WalletConnect
                    </button>
                    <button class="wallet-btn" onclick="connectWallet('auto')" id="autoBtn">
                        üîó Auto-detect
                    </button>
                </div>
                
                <button onclick="refreshData()" id="refreshBtn" disabled>üîÑ Refresh Data</button>
                <button onclick="disconnectWallet()" id="disconnectBtn" disabled>‚ùå Disconnect</button>
            </div>
            
            <div class="section">
                <h3>üíæ Store New Value</h3>
                <p style="margin-bottom: 15px; color: #6c757d;">Only the contract owner can store values. This demonstrates access control in smart contracts.</p>
                <input type="number" id="storeInput" placeholder="Enter any number (e.g., 42, 1337, 2024)" />
                <button onclick="storeValue()" id="storeBtn" disabled>üíæ Store Value</button>
                <div id="storeStatus"></div>
            </div>
            
            <div class="section">
                <h3>üëë Transfer Ownership</h3>
                <p style="margin-bottom: 15px; color: #6c757d;">Transfer contract ownership to another Ethereum address. Be careful - this action cannot be undone!</p>
                <input type="text" id="newOwnerInput" placeholder="New owner address (0x...)" />
                <button onclick="transferOwnership()" id="transferBtn" disabled>üëë Transfer Ownership</button>
                <div id="transferStatus"></div>
            </div>
            
            <div class="section">
                <h3>üìú Recent Storage Events</h3>
                <p style="margin-bottom: 15px; color: #6c757d;">View recent storage transactions recorded on the blockchain.</p>
                <button onclick="getEvents()" id="eventsBtn" disabled>üìú Load Recent Events</button>
                <div id="events"></div>
            </div>
            
            <div class="section">
                <h3>üîß Contract Functions</h3>
                <p style="margin-bottom: 15px; color: #6c757d;">Test individual contract functions:</p>
                <button onclick="testRetrieve()" id="retrieveBtn" disabled>üìñ Call retrieve()</button>
                <button onclick="testNumber()" id="numberBtn" disabled>üî¢ Call number()</button>
                <button onclick="testOwner()" id="ownerBtn" disabled>üë§ Call owner()</button>
                <button onclick="testGetContractInfo()" id="infoBtn" disabled>‚ÑπÔ∏è Call getContractInfo()</button>
                <div id="functionResults"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>Built with ‚ù§Ô∏è using Solidity, Ethers.js, and deployed on GIWA Sepolia Testnet</p>
            <p>Contract Address: <code>0x61123b7a22d2f1b8c2c4becc8333e8e4209cce28</code></p>
        </div>
    </div>

    <script>
        // Multiple CDN fallback for ethers.js
        const ethersCDNs = [
            'https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js',
            'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
            'https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js'
        ];

        let currentCDNIndex = 0;

        function loadEthers() {
            return new Promise((resolve, reject) => {
                if (typeof window.ethers !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = ethersCDNs[currentCDNIndex];
                
                script.onload = () => {
                    if (typeof window.ethers !== 'undefined') {
                        resolve();
                    } else {
                        tryNextCDN(resolve, reject);
                    }
                };
                
                script.onerror = () => {
                    tryNextCDN(resolve, reject);
                };
                
                document.head.appendChild(script);
                
                // Timeout fallback
                setTimeout(() => {
                    if (typeof window.ethers === 'undefined') {
                        tryNextCDN(resolve, reject);
                    }
                }, 5000);
            });
        }

        function tryNextCDN(resolve, reject) {
            currentCDNIndex++;
            if (currentCDNIndex < ethersCDNs.length) {
                loadEthers().then(resolve).catch(reject);
            } else {
                reject(new Error('Failed to load ethers.js from all CDNs'));
            }
        }

        // Initialize app when DOM is ready
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                document.getElementById('libraryStatus').innerHTML = 'üìö Loading Ethers.js library...';
                
                await loadEthers();
                
                document.getElementById('libraryStatus').innerHTML = '‚úÖ Ethers.js loaded successfully!';
                document.getElementById('libraryStatus').style.background = '#d4edda';
                document.getElementById('libraryStatus').style.color = '#155724';
                
                initializeApp();
            } catch (error) {
                console.error('Failed to load ethers.js:', error);
                document.getElementById('libraryStatus').innerHTML = `
                    ‚ùå Failed to load Ethers.js library from all sources.<br>
                    <small>Try refreshing the page or check your internet connection.</small>
                `;
                document.getElementById('libraryStatus').style.background = '#f8d7da';
                document.getElementById('libraryStatus').style.color = '#721c24';
            }
        });

        // Global variables
        let provider, signer, contract, userAddress, isConnected = false, connectedWalletType = '';
        
        // Contract configuration
        const CONTRACT_ADDRESS = "0x61123b7a22d2f1b8c2c4becc8333e8e4209cce28";
        const GIWA_SEPOLIA_CHAIN_ID = "0x1A249"; // 913421 in hex
        
        const ABI = [
            "function store(uint256 num)",
            "function retrieve() view returns (uint256)",
            "function number() view returns (uint256)",
            "function owner() view returns (address)",
            "function transferOwnership(address newOwner)",
            "function getContractInfo() view returns (uint256, address, uint256)",
            "event NumberStored(uint256 indexed newValue, address indexed setter, uint256 timestamp)"
        ];

        async function initializeApp() {
            try {
                // Check if already connected to any wallet
                if (await isAnyWalletConnected()) {
                    await connectWallet('auto');
                }
            } catch (error) {
                console.error('Failed to initialize app:', error);
                showStatus('Failed to initialize app: ' + error.message, 'error', 'storeStatus');
            }
        }

        async function isAnyWalletConnected() {
            try {
                if (typeof window.ethereum !== 'undefined') {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    return accounts.length > 0;
                }
            } catch (error) {
                console.error('Error checking wallet connection:', error);
            }
            return false;
        }

        function detectWalletType() {
            if (typeof window.ethereum !== 'undefined') {
                if (window.ethereum.isRabby) return 'Rabby';
                if (window.ethereum.isMetaMask) return 'MetaMask';
                if (window.ethereum.isCoinbaseWallet) return 'Coinbase Wallet';
                if (window.ethereum.isWalletConnect) return 'WalletConnect';
                return 'Unknown Wallet';
            }
            return 'No Wallet';
        }

        async function connectWallet(walletType = 'auto') {
            try {
                if (typeof window.ethereum === 'undefined') {
                    showStatus('No Ethereum wallet detected. Please install MetaMask, Rabby, or another compatible wallet.', 'error', 'storeStatus');
                    return;
                }

                if (typeof ethers === 'undefined') {
                    showStatus('Ethers.js library not loaded. Please refresh the page.', 'error', 'storeStatus');
                    return;
                }

                showStatus('Connecting to wallet...', 'info', 'storeStatus');

                // Handle specific wallet connections
                if (walletType === 'rabby' && !window.ethereum.isRabby) {
                    showStatus('Rabby wallet not detected. Please install Rabby or use auto-detect.', 'error', 'storeStatus');
                    return;
                }

                if (walletType === 'metamask' && !window.ethereum.isMetaMask && window.ethereum.isRabby) {
                    showStatus('MetaMask not detected (Rabby found instead). Please disable Rabby or use auto-detect.', 'error', 'storeStatus');
                    return;
                }

                // Request account access
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                userAddress = await signer.getAddress();
                
                // Detect and store wallet type
                connectedWalletType = detectWalletType();
                
                // Check network
                const network = await provider.getNetwork();
                document.getElementById('networkName').textContent = network.name === 'unknown' ? `Chain ID: ${network.chainId}` : network.name;
                
                if (network.chainId !== 913421) {
                    showStatus('‚ö†Ô∏è Please switch to GIWA Sepolia Testnet (Chain ID: 913421)', 'warning', 'storeStatus');
                    await switchToGiwaSepolia();
                    return;
                }
                
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
                
                // Update UI
                document.getElementById('userAddress').textContent = userAddress;
                document.getElementById('connectedWallet').textContent = connectedWalletType;
                
                // Update wallet buttons
                updateWalletButtons(connectedWalletType);
                
                // Enable buttons
                enableButtons();
                isConnected = true;
                
                await refreshData();
                showStatus(`${connectedWalletType} connected successfully! üéâ`, 'success', 'storeStatus');
                
            } catch (error) {
                console.error('Connection error:', error);
                if (error.code === 4001) {
                    showStatus('Connection cancelled by user', 'warning', 'storeStatus');
                } else {
                    showStatus('Failed to connect wallet: ' + error.message, 'error', 'storeStatus');
                }
            }
        }

        function updateWalletButtons(connectedWallet) {
            const buttons = document.querySelectorAll('.wallet-btn');
            buttons.forEach(btn => {
                btn.classList.remove('connected');
            });
            
            // Mark connected wallet
            if (connectedWallet.toLowerCase().includes('metamask')) {
                document.getElementById('metamaskBtn').classList.add('connected');
            } else if (connectedWallet.toLowerCase().includes('rabby')) {
                document.getElementById('rabbyBtn').classList.add('connected');
            } else if (connectedWallet.toLowerCase().includes('coinbase')) {
                document.getElementById('coinbaseBtn').classList.add('connected');
            }
        }

        async function disconnectWallet() {
            try {
                provider = null;
                signer = null;
                contract = null;
                userAddress = '';
                isConnected = false;
                connectedWalletType = '';
                
                // Reset UI
                document.getElementById('userAddress').textContent = 'Not connected';
                document.getElementById('connectedWallet').textContent = 'None';
                document.getElementById('currentValue').textContent = 'Not connected';
                document.getElementById('contractOwner').textContent = 'Not connected';
                document.getElementById('isOwner').textContent = 'Unknown';
                document.getElementById('networkName').textContent = 'Not connected';
                
                // Reset wallet buttons
                document.querySelectorAll('.wallet-btn').forEach(btn => {
                    btn.classList.remove('connected');
                });
                
                // Disable buttons
                disableButtons();
                
                showStatus('Wallet disconnected', 'info', 'storeStatus');
            } catch (error) {
                console.error('Disconnect error:', error);
                showStatus('Error disconnecting: ' + error.message, 'error', 'storeStatus');
            }
        }

        async function switchToGiwaSepolia() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: GIWA_SEPOLIA_CHAIN_ID }],
                });
                // Retry connection after network switch
                setTimeout(() => connectWallet('auto'), 1000);
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: GIWA_SEPOLIA_CHAIN_ID,
                                chainName: 'GIWA Sepolia Testnet',
                                nativeCurrency: {
                                    name: 'ETH',
                                    symbol: 'ETH',
                                    decimals: 18
                                },
                                rpcUrls: ['https://sepolia-rpc.giwa.io'], // Replace with actual RPC URL
                                blockExplorerUrls: ['https://sepolia-explorer.giwa.io'] // Replace with actual explorer URL
                            }]
                        });
                        setTimeout(() => connectWallet('auto'), 1000);
                    } catch (addError) {
                        showStatus('Failed to add GIWA Sepolia network. Please add it manually to your wallet.', 'error', 'storeStatus');
                    }
                } else {
                    showStatus('Failed to switch network: ' + switchError.message, 'error', 'storeStatus');
                }
            }
        }

        function enableButtons() {
            const buttons = ['refreshBtn', 'disconnectBtn', 'storeBtn', 'transferBtn', 'eventsBtn', 'retrieveBtn', 'numberBtn', 'ownerBtn', 'infoBtn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = false;
            });
        }

        function disableButtons() {
            const buttons = ['refreshBtn', 'disconnectBtn', 'storeBtn', 'transferBtn', 'eventsBtn', 'retrieveBtn', 'numberBtn', 'ownerBtn', 'infoBtn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = true;
            });
        }

        async function refreshData() {
            if (!isConnected || !contract) {
                showStatus('Please connect your wallet first', 'error', 'storeStatus');
                return;
            }

            try {
                showStatus('Loading contract data...', 'info', 'storeStatus');
                
                const [currentValue, owner] = await Promise.all([
                    contract.number(),
                    contract.owner()
                ]);
                
                const isOwner = userAddress && userAddress.toLowerCase() === owner.toLowerCase();
                
                document.getElementById('currentValue').textContent = currentValue.toString();
                document.getElementById('contractOwner').textContent = owner;
                document.getElementById('isOwner').textContent = isOwner ? 'Yes ‚úÖ' : 'No ‚ùå';
                
                showStatus('Data refreshed successfully! ‚úÖ', 'success', 'storeStatus');
                
            } catch (error) {
                console.error('Refresh error:', error);
                showStatus('Failed to load contract data: ' + error.message, 'error', 'storeStatus');
            }
        }

        async function storeValue() {
            if (!isConnected || !signer) {
                showStatus('Please connect your wallet first', 'error', 'storeStatus');
                return;
            }

            const value = document.getElementById('storeInput').value.trim();
            if (!value || isNaN(value)) {
                showStatus('Please enter a valid number', 'error', 'storeStatus');
                return;
            }

            try {
                showStatus(`Preparing transaction... Please confirm in ${connectedWalletType}`, 'info', 'storeStatus');
                
                const tx = await contract.connect(signer).store(value);
                showStatus(`Transaction sent! Hash: ${tx.hash}. Waiting for confirmation...`, 'info', 'storeStatus');
                
                const receipt = await tx.wait();
                showStatus(`‚úÖ Value ${value} stored successfully! Block: ${receipt.blockNumber}`, 'success', 'storeStatus');
                
                document.getElementById('storeInput').value = '';
                await refreshData();
                
            } catch (error) {
                console.error('Store error:', error);
                if (error.message.includes('Only owner')) {
                    showStatus('‚ùå Access denied! Only the contract owner can store values.', 'error', 'storeStatus');
                } else if (error.code === 4001) {
                    showStatus('Transaction cancelled by user', 'warning', 'storeStatus');
                } else {
                    showStatus('Transaction failed: ' + error.message, 'error', 'storeStatus');
                }
            }
        }

        async function transferOwnership() {
            if (!isConnected || !signer) {
                showStatus('Please connect your wallet first', 'error', 'transferStatus');
                return;
            }

            const newOwner = document.getElementById('newOwnerInput').value.trim();
            if (!newOwner) {
                showStatus('Please enter a new owner address', 'error', 'transferStatus');
                return;
            }

            if (!ethers.utils.isAddress(newOwner)) {
                showStatus('Please enter a valid Ethereum address', 'error', 'transferStatus');
                return;
            }

            if (!confirm(`Are you sure you want to transfer ownership to ${newOwner}? This cannot be undone!`)) {
                return;
            }

            try {
                showStatus(`Preparing ownership transfer... Please confirm in ${connectedWalletType}`, 'info', 'transferStatus');
                
                const tx = await contract.connect(signer).transferOwnership(newOwner);
                showStatus(`Transaction sent! Hash: ${tx.hash}. Waiting for confirmation...`, 'info', 'transferStatus');
                
                const receipt = await tx.wait();
                showStatus(`‚úÖ Ownership transferred to ${newOwner} successfully! Block: ${receipt.blockNumber}`, 'success', 'transferStatus');
                
                document.getElementById('newOwnerInput').value = '';
                await refreshData();
                
            } catch (error) {
                console.error('Transfer error:', error);
                if (error.message.includes('Only owner')) {
                    showStatus('‚ùå Access denied! Only the current owner can transfer ownership.', 'error', 'transferStatus');
                } else if (error.code === 4001) {
                    showStatus('Transaction cancelled by user', 'warning', 'transferStatus');
                } else {
                    showStatus('Transaction failed: ' + error.message, 'error', 'transferStatus');
                }
            }
        }

        async function getEvents() {
            if (!isConnected || !contract) {
                showStatus('Please connect your wallet first', 'error', 'events');
                return;
            }

            try {
                showStatus('Loading recent events...', 'info', 'events');
                
                const filter = contract.filters.NumberStored();
                const events = await contract.queryFilter(filter, -1000);
                
                let eventsHtml = '';
                if (events.length === 0) {
                    eventsHtml = '<div class="status info">No storage events found in recent blocks</div>';
                } else {
                    eventsHtml = `<h4 style="margin-bottom: 15px;">Found ${events.length} storage events:</h4>`;
                    events.reverse().slice(0, 10).forEach((event, index) => {
                        const date = new Date(event.args.timestamp * 1000);
                        eventsHtml += `
                            <div class="event-item">
                                <h5>Event #${index + 1}</h5>
                                <p><strong>Value Stored:</strong> ${event.args.newValue.toString()}</p>
                                <p><strong>Stored By:</strong> ${event.args.setter}</p>
                                <p><strong>Timestamp:</strong> ${date.toLocaleString()}</p>
                                <p><strong>Block Number:</strong> ${event.blockNumber}</p>
                                <p><strong>Transaction Hash:</strong> ${event.transactionHash}</p>
                            </div>
                        `;
                    });
                    if (events.length > 10) {
                        eventsHtml += `<div class="status info">Showing latest 10 of ${events.length} events</div>`;
                    }
                }
                
                document.getElementById('events').innerHTML = eventsHtml;
                
            } catch (error) {
                console.error('Events error:', error);
                showStatus('Failed to load events: ' + error.message, 'error', 'events');
            }
        }

        // Test individual contract functions
        async function testRetrieve() {
            await testFunction('retrieve', 'retrieve()');
        }

        async function testNumber() {
            await testFunction('number', 'number()');
        }

        async function testOwner() {
            await testFunction('owner', 'owner()');
        }

        async function testGetContractInfo() {
            try {
                const result = await contract.getContractInfo();
                const [number, owner, balance] = result;
                showFunctionResult(`getContractInfo() returned:<br>
                    Number: ${number.toString()}<br>
                    Owner: ${owner}<br>
                    Balance: ${ethers.utils.formatEther(balance)} ETH`);
            } catch (error) {
                showFunctionResult(`getContractInfo() failed: ${error.message}`, 'error');
            }
        }

        async function testFunction(functionName, displayName) {
            if (!isConnected || !contract) {
                showFunctionResult('Please connect your wallet first', 'error');
                return;
            }

            try {
                const result = await contract[functionName]();
                showFunctionResult(`${displayName} returned: ${result.toString()}`);
            } catch (error) {
                showFunctionResult(`${displayName} failed: ${error.message}`, 'error');
            }
        }

        function showFunctionResult(message, type = 'success') {
            const element = document.getElementById('functionResults');
            if (element) {
                element.innerHTML = `<div class="status ${type}">${message}</div>`;
            }
        }

        function showStatus(message, type, elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = `<div class="status ${type}">${message}</div>`;
                if (type === 'success') {
                    setTimeout(() => {
                        element.innerHTML = '';
                    }, 5000);
                }
            }
        }

        // Handle account and network changes for all wallets
        if (typeof window !== 'undefined' && typeof window.ethereum !== 'undefined') {
            // Account changes
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else {
                    location.reload();
                }
            });

            // Network changes
            window.ethereum.on('chainChanged', (chainId) => {
                location.reload();
            });

            // Connection changes
            window.ethereum.on('connect', (connectInfo) => {
                console.log('Wallet connected:', connectInfo);
            });

            window.ethereum.on('disconnect', (error) => {
                console.log('Wallet disconnected:', error);
                disconnectWallet();
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey || event.metaKey) {
                switch(event.key) {
                    case 'r':
                        event.preventDefault();
                        if (!document.getElementById('refreshBtn').disabled) {
                            refreshData();
                        }
                        break;
                    case 'Enter':
                        if (event.target.id === 'storeInput') {
                            event.preventDefault();
                            storeValue();
                        } else if (event.target.id === 'newOwnerInput') {
                            event.preventDefault();
                            transferOwnership();
                        }
                        break;
                }
            }
        });

        // Auto-refresh data every 30 seconds when connected
        setInterval(() => {
            if (isConnected && contract) {
                refreshData();
            }
        }, 30000);

        // Prevent form submission on Enter key
        document.addEventListener('keypress', function(event) {
            if (event.key === 'Enter' && event.target.tagName === 'INPUT') {
                event.preventDefault();
                if (event.target.id === 'storeInput') {
                    storeValue();
                } else if (event.target.id === 'newOwnerInput') {
                    transferOwnership();
                }
            }
        });

        // Add visual feedback for wallet detection
        function updateWalletAvailability() {
            const wallets = [
                { id: 'metamaskBtn', condition: window.ethereum?.isMetaMask, name: 'MetaMask' },
                { id: 'rabbyBtn', condition: window.ethereum?.isRabby, name: 'Rabby' },
                { id: 'coinbaseBtn', condition: window.ethereum?.isCoinbaseWallet, name: 'Coinbase Wallet' },
                { id: 'walletconnectBtn', condition: typeof window.WalletConnect !== 'undefined', name: 'WalletConnect' }
            ];

            wallets.forEach(wallet => {
                const btn = document.getElementById(wallet.id);
                if (btn) {
                    if (!wallet.condition) {
                        btn.style.opacity = '0.5';
                        btn.title = `${wallet.name} not detected`;
                    } else {
                        btn.style.opacity = '1';
                        btn.title = `Connect with ${wallet.name}`;
                    }
                }
            });
        }

        // Check wallet availability on load
        setTimeout(updateWalletAvailability, 1000);

        // Error handling for unhandled promise rejections
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            if (event.reason?.message) {
                showStatus('Unexpected error: ' + event.reason.message, 'error', 'storeStatus');
            }
        });

        // Service worker registration for offline functionality (optional)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                // Uncomment if you want to add a service worker
                // navigator.serviceWorker.register('/sw.js');
            });
        }

        console.log('üöÄ Storage V2 DApp initialized successfully!');
    </script>
</body>
</html>
